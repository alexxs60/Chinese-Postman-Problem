ChinesePostmanProblem - 中国邮路问题求解系统 (C++ 课程设计)
一个基于 C++ 的 中国邮路问题（Chinese Postman Problem）完整求解程序，能够在连通的无向加权图中找到遍历每条边至少一次的最短闭合回路（邮递员最优路线）。
项目亮点

实现了 中国邮路问题 经典完整流程：奇度节点检测 → 最小权重完美匹配 → 添加重复边 → 欧拉回路 求解
使用递归方式求解奇度节点的最小完美匹配（适合小规模图）
支持多重边处理（multiset 实现），正确处理重复遍历的边
包含 图连通性检查、路径完整性验证、运行时间统计
支持两种输入方式：键盘交互输入 + 文件一次性输入
输出直观：最佳路线节点序列 + 总路程 + 额外添加成本 + 遍历边数统计

技术栈

C++11（兼容性好，大多数环境可直接编译）
STL：vector、stack、multiset、algorithm、chrono、fstream
核心算法：
Floyd-Warshall（所有点对最短路径 + 路径重构）
递归 最小完美匹配（奇度节点配对）
Hierholzer 算法（高效求 欧拉回路）

数据结构：邻接矩阵（权重）、multiset（多重边）、父指针（路径恢复）
文件 I/O + 性能计时（chrono 高精度计时）

主要功能

图的输入与构建（键盘 / 文件）
自动检测 奇度节点
计算奇度节点间的最小权重完美匹配
根据匹配结果添加重复边（最短路径上的边重复）
从指定起始节点求解 欧拉回路
输出最优投递路线（节点序列）、总路程、额外成本、遍历边数
验证图是否连通、路径是否覆盖所有边
记录算法运行时间（毫秒级）

项目结构
Chinese-Postman-Problem/
├── main.cpp                主程序（输入、算法调用、输出）
├── test1.txt               全偶度节点示例（无需添加边）
├── test2.txt               4奇度节点示例（直接边匹配）
├── test3.txt               4奇度节点示例（包含最短路径多段）
└── README.md               本说明文件
编译与运行
编译命令
g++ -std=c++11 main.cpp -o cpp
或带优化
g++ -std=c++11 -O2 main.cpp -o cpp
运行
./cpp                # Linux / Mac
cpp.exe              # Windows
启动后选择：

文件输入（推荐，输入 test*.txt 文件名）
键盘输入（手动输入节点数、边数、边信息）

测试用例一览
文件名     奇度节点数  预期总路程  说明
test1.txt  0          28         所有节点偶度，直接欧拉回路
test2.txt  4          42         需要添加两条边（匹配成本6）
test3.txt  4          14         匹配成本2，涉及最短路径多段添加
test1.txt 示例内容：
4 4 0
0 1 4
1 2 6
2 3 8
3 0 10
注意事项

节点编号必须从 0 开始
图必须是连通的（程序会检查并提示）
奇度节点个数必须是偶数（否则无法完美匹配）
奇度节点超过 10～12 个时递归匹配会变慢（指数复杂度）
权重建议为正整数（负权/零权未做处理）
路线顺序可能因 multiset 自动排序而不同，但只要总路程正确且覆盖所有边即合法

作者
Display Name: kira
完成时间：2026年
课程：图论 / 算法设计与分析 / 数据结构课程设计
欢迎 Star / Fork / 提 Issue！